#include <iostream>
#include <fstream>
#include <conio.h>
#include <windows.h>
#include <set>
#include <vector>
#include <algorithm>

using namespace std;
HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE); /* Отримання
дескриптора пристрою стандартного виводу, а саме консолі*/
//задаємо константи, що визначають довжину символьних полів: Виробник, Модель, Тип, Рік випуску.
const int l_manufacturer = 30, l_model = 30, l_matrix_size = 30, l_matrix_type = 30, l_light_sensitivity = 30, l_memory_card = 10;
const int countZinP = 50; // оголошуємо константу, що регламентує кількість записів на екрані

//основна структура
struct iin
{
	char manufacturer[l_manufacturer];
	char model[l_model];
	float price;
	char matrix_size[l_matrix_size];
	char matrix_type[l_matrix_type];
	char light_sensitivity[l_light_sensitivity];
	int memory_card;
};

// глобальні змінні
fstream f; // файлова змінна
char fdir[100] = "1.txt"; // змінна для збереження повного імені файлу
void menu(); // попереднє оголошення процедури

// *** Процедура створення/відкриття файлу ***
void open_new()
{
	system("cls");
	printf(" Вкажіть повне ім'я файлу ( Приклад: \"С:\\Program Files\\file.dat\" ): ");
	cin >> fdir;
	cin.ignore();
opf:
	f.open(fdir, ios::in | ios::out | ios::binary); // відкриваємо файл у бінарному режимі
	if (!f.is_open()) //якщо файл не відкрився
	{
		printf("\n\n Помилка при відкритті файлу, буде спроба його створити.\n\n\n ");
		ofstream ofs(fdir); //створюємо файл
		ofs.close(); //закриваємо потік створеного файлу
		printf(" Файл створено. \n\n ");
		goto opf;
	}
	else
		printf(" Файл відкрито для роботи. \n\n ");
	system("pause");
}

// *** Процедура додавання запису ***
void addzap()
{
	system("cls");
	int i, // змінна призначена для номера нового запису
		pp, // змінна для збереження натиснутої клавіші
		j, // змінна для збереження довжини символьних змінних
		t, // змінна для збереження довжини символьних змінних
		q1;
	iin photo; // оголошуємо змінну для роботи із записом
	f.clear(); // очищуємо прапорці помилок
	f.seekg(0, ios::end); // переводимо вказівник на кінець файлу
	i = f.tellp() / sizeof(struct iin); //визначаємо кількість записів 
s11:
	i++; //номер нового запису
	// обнулюяємо поля запису
	strcpy(photo.manufacturer, "");
	strcpy(photo.model, "");
	photo.price = 0.0;
	strcpy(photo.matrix_size, "");
	strcpy(photo.matrix_type, "");
	strcpy(photo.light_sensitivity, "");
	photo.memory_card = 0;
	pp = 0;
	//далі заповнюємо поля нового запису
	cout << " Запис № " << i << ": \n";

	cout << "\n Виробник -> ";
	do
	{
		gets_s(photo.manufacturer); // зчитуємо значення у символьне поле
		t = strlen(photo.manufacturer); //визначаємо довжину символьного поля
	} while (t == 0); // цикл буде виконуватися до тих пір, поки довжина введеного символьного поля буде нульовою
	for (j = t; j < l_manufacturer - 1; j++) // цикл забезпечує додавання до символьного поля пробілів до заданої довжини
		strcat(photo.manufacturer, " ");

	cout << "\n Модель -> ";
	do
	{
		gets_s(photo.model); // зчитуємо значення у символьне поле
		t = strlen(photo.model); //визначаємо довжину символьного поля
	} while (t == 0); // цикл буде виконуватися до тих пір, поки довжина введеного символьного поля буде нульовою
	for (j = t; j < l_model - 1; j++) // цикл забезпечує додавання до символьного поля пробілів до заданої довжини
		strcat(photo.model, " ");

	cout << "\n Ціна -> ";
	do
	{
		cin >> photo.price; // зчитуємо значення у числове поле
	} while (t == 0); // цикл буде виконуватися до тих пір, поки довжина введеного символьного поля буде нульовою

	cout << "\n Розмір матриці -> ";
	do
	{
		gets_s(photo.matrix_size); // зчитуємо значення у символьне поле
		t = strlen(photo.matrix_size); //визначаємо довжину символьного поля
	} while (t == 0); // цикл буде виконуватися до тих пір, поки довжина введеного символьного поля буде нульовою
	for (j = t; j < l_matrix_size - 1; j++) // цикл забезпечує додавання до символьного поля пробілів до заданої довжини
		strcat(photo.matrix_size, " ");

	cout << "\n Тип матриці -> ";
	do
	{
		gets_s(photo.matrix_type); // зчитуємо значення у символьне поле
		t = strlen(photo.matrix_type); //визначаємо довжину символьного поля
	} while (t == 0); // цикл буде виконуватися до тих пір, поки довжина введеного символьного поля буде нульовою
	for (j = t; j < l_matrix_type - 1; j++) // цикл забезпечує додавання до символьного поля пробілів до заданої довжини
		strcat(photo.matrix_type, " ");

	cout << "\n Світлочутливість -> ";
	do
	{
		gets_s(photo.light_sensitivity); // зчитуємо значення у символьне поле
		t = strlen(photo.light_sensitivity); //визначаємо довжину символьного поля
	} while (t == 0); // цикл буде виконуватися до тих пір, поки довжина введеного символьного поля буде нульовою
	for (j = t; j < l_light_sensitivity - 1; j++) // цикл забезпечує додавання до символьного поля пробілів до заданої довжини
		strcat(photo.light_sensitivity, " ");

	cout << "\n Карта пам'яті -> ";
	do
	{
		cin >> photo.memory_card; // зчитуємо значення у числове поле
	} while (t == 0); // цикл буде виконуватися до тих пір, поки довжина введеного символьного поля буде нульовою

	f.write((char*)&photo, sizeof(struct iin)); // записуємо у файл сформований запис
s12:
	cout << " Для введення ще одного запису натисніть -> Enter, для закінчення -> Esc \n";
	if ((pp = _getch()) != 27)
		if (pp == 13)
			goto s11;
		else
			goto s12;
}

// *** Процедура виведення усіх записів ***
void all_out()
{
	iin zap; // оголошуємо змінну для роботи із записом
	int space; // оголошуємо змінну, що є лічильником кількості записів на екрані
	int position = 0; // враховує к-сть виведених записів на сторінці
	int im = 0; // змінна для збереження коду натиснутої клавіші
	f.clear(); // очищуємо прапорці помилок
	f.seekp(0, ios::end); // переміщуємо вказівник на кінець файлу
	int size = f.tellp() / sizeof(struct iin); // визначаємо кількість записів у файлі
	if (size < 1)
	{ // якщо записів немає, то дати повідомлення на екран
		system("cls");
		cout << "Файл порожній\n";
		system("pause");
		goto ex; // перехід на закінчення виконання процедури
	}

star:
	f.clear(); // очищуємо прапорці помилок
	f.seekp(position * countZinP * sizeof(struct iin), ios::beg); // переміщуємо вказівник на потрібний запис, що вираховується за наступною формулою

	system("cls");
	printf("|<<< Загальна кількість записів у файлі = %5d >>>|\n", size);
	cout << ".___._______________.________________________.______________________.________________.______________.____________________________._________________.\n";
	cout << "| № |   Виробник    |         Модель         |        Ціна          | Розмір матриці | Тип матриці  |      Світлочутивість       |  Карта пам'яті  |\n";
	cout << "|===|===============|========================|======================|================|==============|============================|=================|\n";
	space = 0; //обнуляємо значення лічильника кількості записів на екрані
	while ((!f.eof()) && (space < countZinP)) //умова виконання циклу: поки не досягли кінця файлу або кількість виведених записів на екран менше countZinP
	{
		f.read((char*)&zap, sizeof(struct iin)); //зчитування запису з файлу у змінну zap
		if (f.eof()) break; // якщо досягнуто кінець файлу, то вийти з циклу
		// виводимо поля зчитаного запису на екран
		printf("|%2d | %.14s| %.23s| %11f          | %.15s| %.13s| %.27s| %7d GB      |\n", ((1 + space) + ((position)*countZinP)), zap.manufacturer, zap.model, zap.price, zap.matrix_size, zap.matrix_type, zap.light_sensitivity, zap.memory_card);
		space++; //збільшуємо лічильник кількості записів на екрані на 1
	}
	cout << "|___|_______________|________________________|______________________|________________|______________|____________________________|_________________|\n";
	printf("|<<<\"Up/Down - переміщення на стор.\"<<< №%2d >>>\"Esc -головне меню \">>>|\n", position + 1);
ctrl:
	im = _getch(); // зчитуємо код натиснутої клавіші
	switch (im)
	{
	case 80: // якщо натиснута клавіша "стрілка вниз" - Down
	{
		if (position < (size - 1) / countZinP)
			++position;
		goto star; //повернення до мітки star:
	}
	case 72: // якщо натиснута клавіша "стрілка у гору" - Up
	{
		if (position >= 1)
			--position;
		goto star; //перехід до мітки star:
	}
	case 27:
		goto ex;
	default:
		goto ctrl;
	}
ex:;
}

// *** Процедура редагування запису ***
void editzap()
{
	int t, i = 0, j, q1;
	int im; // змінна для збереження коду натиснутої клавіші


start:
	system("cls");
	iin zap; // оголошуємо змінну для роботи із записом
	int nom = 0; //номер запису для редагування

	int size = f.tellp() / sizeof(struct iin); // визначаємо кількість записів у файлі
	if (size < 1)
	{ // якщо записів немає, то дати повідомлення на екран
		system("cls");
		cout << "Файл порожній\n";
		system("pause");
		goto ex; // перехід на закінчення виконання процедури
	}

	cout << "Введіть номер запису, що буде відредаговано -> ";
	cin >> nom;
	f.clear();
	f.seekp((nom - 1) * sizeof(struct iin), ios::beg);//Переміщуємо вказівник на потрібний запис
	cout << ".___._______________.________________________.______________________.________________.______________.____________________________._________________.\n";
	cout << "| № |   Виробник    |         Модель         |        Ціна          | Розмір матриці | Тип матриці  |      Світлочутивість       |  Карта пам'яті  |\n";
	cout << "|===|===============|========================|======================|================|==============|============================|=================|\n";
	f.read((char*)&zap, sizeof(struct iin));
	{
		printf("|%2d | %.14s| %.23s| %11f          | %.15s| %.13s| %.27s| %7d GB      |\n", nom, zap.manufacturer, zap.model, zap.price, zap.matrix_size, zap.matrix_type, zap.light_sensitivity, zap.memory_card);
	}
	cout << "|___|_______________|________________________|______________________|________________|______________|____________________________|_________________|\n";
	printf("|<<<<<<<\"Для підтвердження редагування натисніть Enter, а для відміни Esc\">>>>>>>|\n");
control:
	im = _getch(); // зчитуємо код натиснутої клавіші
	if (im == 13)
	{
		iin prod; // оголошуємо змінну для роботи із записом
		// обнулюяємо поля запису

		strcpy(prod.manufacturer, "");
		strcpy(prod.model, "");
		prod.price = 0.0;
		strcpy(prod.matrix_size, "");
		strcpy(prod.matrix_type, "");
		strcpy(prod.light_sensitivity, "");
		prod.memory_card = 0;
		//далі заповнюємо поля нового запису
		cout << "Запис № " << i << ": \n";

		cout << " Виробник -> ";
		do
		{
			gets_s(prod.manufacturer);
			t = strlen(prod.manufacturer);
		} while (t == 0);
		for (j = t; j < l_manufacturer - 1; j++)
			strcat(prod.manufacturer, " ");

		cout << "\n Модель -> ";
		do
		{
			gets_s(prod.model);
			t = strlen(prod.model);
		} while (t == 0);
		for (j = t; j < l_model - 1; j++)
			strcat(prod.model, " ");

		cout << "\n Ціна -> ";
		do
		{
			cin >> prod.price;
		} while (t == 0);

		cout << "\n Розмір матриці -> ";
		do
		{
			gets_s(prod.matrix_size);
			t = strlen(prod.matrix_size);
		} while (t == 0);
		for (j = t; j < l_matrix_size - 1; j++)
			strcat(prod.matrix_size, " ");

		cout << "\n Тип матриці -> ";
		do
		{
			gets_s(prod.matrix_type);
			t = strlen(prod.matrix_type);
		} while (t == 0);
		for (j = t; j < l_matrix_type - 1; j++)
			strcat(prod.matrix_type, " ");

		cout << "\n Cвітлочутливість -> ";
		do
		{
			gets_s(prod.light_sensitivity);
			t = strlen(prod.light_sensitivity);
		} while (t == 0);
		for (j = t; j < l_light_sensitivity - 1; j++)
			strcat(prod.light_sensitivity, " ");

		cout << "\n Карта пам'яті -> ";
		do
		{
			cin >> prod.memory_card;
		} while (t == 0);

		printf("|<<<<<<<\"Для підтвердження редагування натисніть Enter, а для відміни Esc\">>>>>>>|\n");
	control2:
		im = _getch(); // зчитуємо код натиснутої клавіші
		if (im == 13) // якщо натиснута клавіша Enter
		{
			f.seekp((nom - 1) * sizeof(struct iin), ios::beg); // переміщуємо вказівник на запис, що буде замінено
			f.write((char*)&prod, sizeof(struct iin)); // записуємо у файл новий запис
			goto start;
		}
		else
			if (im == 27) //якщо натиснута клавіша є Esc
				goto start;
		goto control2;
	}
	else
		if (im != 27) //якщо натиснута клавіша не є Esc
			goto control;
ex:;
}

// *** Процедура видалення запису ***
void delzap()
{
	system("cls");
	iin zap; // оголошуємо змінну для роботи із записом
	int im = 0; // змінна для збереження коду натиснутої клавіші
	int nom = 0; // змінна для номеру запису, що буде видалено з файлу

	f.clear(); // очищуємо прапорці помилок
	f.seekp(0, ios::end); // переміщуємо вказівник на кінець файлу
	int size = f.tellp() / sizeof(struct iin); // визначаємо кількість записів у файлі
	if (size < 1)
	{ // якщо записів немає, то дати повідомлення на екран
		system("cls");
		cout << "Файл порожній\n";
		system("pause");
		goto ex; // перехід на закінчення виконання процедури
	}

	cout << "Введіть номер запису, що буде видалено з файлу -> ";
	cin >> nom;
	f.clear(); // очищуємо прапорці помилок
	f.seekp((nom - 1) * sizeof(struct iin), ios::beg);//Переміщуємо вказівник на потрібний запис
	// виводимо поля запису на екран
	cout << "Цей запис буде видалено з файлу \n";
	cout << ".___._______________.________________________.______________________.________________.______________.____________________________._________________.\n";
	cout << "| № |   Виробник    |         Модель         |        Ціна          | Розмір матриці | Тип матриці  |      Світлочутивість       |  Карта пам'яті  |\n";
	cout << "|===|===============|========================|======================|================|==============|============================|=================|\n";
	f.read((char*)&zap, sizeof(struct iin));
	printf("|%2d | %.14s| %.23s| %11f          | %.15s| %.13s| %.27s| %7d GB      |\n", nom, zap.manufacturer, zap.model, zap.price, zap.matrix_size, zap.matrix_type, zap.light_sensitivity, zap.memory_card);
	cout << "|___|_______________|________________________|______________________|________________|______________|____________________________|_________________|\n";
	printf("|<<<\"Для підтвердження редагування натисніть Enter, а для відміни Esc\">>>|\n");
control:
	im = _getch(); // зчитуємо код натиснутої клавіші
	if (im == 13) // якщо натиснута клавіша Enter
	{
		f.clear(); // очищуємо прапорці помилок
		f.seekp(0, ios::end); // переміщуємо вказівник на кінец файлу
		int size = f.tellp() / sizeof(struct iin); //визначаємо кількість записів у файлі
		iin* mas;
		mas = new iin[size + 1]; // виділяємо динамічну пам’ять під масив на кількість записів у файлі
		f.clear(); // очищуємо прапорці помилок
		f.seekp(0, ios::beg); // переміщуємо вказівник на початок у файлі
		int i = 0;
		while (!f.eof())
		{// зчитуємо у динамічний масив записів з файлу
			f.read((char*)&mas[i], sizeof(struct iin));
			i++;
		}
		f.close(); // закриваємо файл
		f.clear(); // очищуємо прапорці помилок
		f.open(fdir, ios::in | ios::out | ios::trunc); // відкриваємо файл та очищуємо його - знищуємо усі записи у файл
		f.seekp(0, ios::beg); // переміщуємо вказівник на початок файлу
		for (i = 0; i < size; i++) //цикл забезпечує запис усіх елементів масиву у файл
			if (i != (nom - 1)) // якщо поточний елемент не дорівнює заданому
				f.write((char*)&mas[i], sizeof(struct iin)); //запис поточного елементу у файл
		delete[]mas; // очищуємо виділену динамічну пам’ять під масив записів
		cout << "Запис видалено \n";
		system("pause");
	}
	else
		if (im != 27) //якщо натиснута клавіша не є Esc
			goto control;
ex:;
}

// *** Процедура завершення роботи програми ***
void exit_prog()
{
	system("cls");
	cout << "\n Натисніть: \n\n Enter для того, щоб вийти. \n\n Esc для того, щоб повернутися в головне меню. \n\n\n";
st:
	int go = _getch(); //зчитуємо натиснуту клавішу
	if (go != 13) // перевірка чи не натиснута клавіша Enter
		if (go == 27) // перевірка чи натиснута клавіша Esc
			goto ex;
		else
			goto st; // буде здійснено перехід на мітку st, якщо буде натиснута клавіша відмінна від Enter та Esc
	if (f.is_open())
		f.close(); // закриваємо файл, якщо він був відкритий
	exit(0); // закриваємо програму / виходимо з неї
ex:;
}

// Процедура порівняння двох рядків
int fyy(char* a, char* b)
{
	int i = 0, j = strlen(a);
	while (j > i)
	{
		if (a[i] != b[i])
			return 0;
		i++;
	}
	return 1;
}

// Процедура для виведення усіх виробників фотоапаратів;
void Task1()
{
	system("cls");

	set<string> uniqueManufacturers; // Набір для зберігання унікальних виробників
	iin zap; // оголошуємо змінну для роботи із записом
	int space; // оголошуємо змінну, що є лічильником кількості записів на екрані
	int position = 0; // враховує к-сть виведених записів на сторінці
	f.clear(); // очищуємо прапорці помилок
	f.seekp(position * countZinP * sizeof(struct iin), ios::beg); // переміщуємо вказівник на потрібний запис, що вираховується за наступною формулою

	cout << ".___._______________.\n";
	cout << "| № |   Виробник    |\n";
	cout << "|===|===============|\n";
	space = 0; //обнуляємо значення лічильника кількості записів на екрані
	while ((!f.eof()) && (space < countZinP)) //умова виконання циклу: поки не досягли кінця файлу або кількість виведених записів на екран менше countZinP
	{
		f.read((char*)&zap, sizeof(struct iin)); //зчитування запису з файлу у змінну zap
		if (f.eof()) break; // якщо досягнуто кінець файлу, то вийти з циклу
		// виводимо поля зчитаного запису на екран
		string manufacturer(zap.manufacturer);
		if (uniqueManufacturers.find(manufacturer) == uniqueManufacturers.end()) // Перевірка чи виробник унікальний
		{
			uniqueManufacturers.insert(manufacturer);
			printf("|%2d | %.14s|\n", ((1 + space) + ((position)*countZinP)), zap.manufacturer);
		}
		space++; //збільшуємо лічильник кількості записів на екрані на 1
	}
	cout << "|___|_______________|\n";
	cout << "\n Натисніть: \n\n Esc для того, щоб повернутися в головне меню. \n\n\n";
l1:
	int go = _getch(); //зчитуємо натиснуту клавішу
	if (go == 27) // перевірка чи натиснута клавіша Esc
	{
		goto ex;
	}
	else
	{
		goto l1;
	}
ex:;
}

//Процедура виводу моделей фотоапаратів із заданим розміром матриці  
void Task2()
{
l1:
	system("cls");
	char y[18];
	cout << "Введіть розмір матриці: ";
	cin.getline(y, 18);
	iin zap;
	int space;
	int position = 0;
	int im = 0;
	f.clear();
	f.seekp(position * countZinP * sizeof(struct iin), ios::beg);

	cout << ".___._______________.________________________.______________________.________________.______________.____________________________._________________.\n";
	cout << "| № |   Виробник    |         Модель         |        Ціна          | Розмір матриці | Тип матриці  |      Світлочутивість       |  Карта пам'яті  |\n";
	cout << "|===|===============|========================|======================|================|==============|============================|=================|\n";
	space = 0;
	while ((!f.eof()) && (space < countZinP))
	{
		f.read((char*)&zap, sizeof(struct iin));
		if (f.eof()) break;
		if (fyy(y, zap.matrix_size) == 1)
		{
			printf("|%2d | %.14s| %.23s| %11f          | %.15s| %.13s| %.27s| %7d GB      |\n", ((1 + space) + ((position)*countZinP)), zap.manufacturer, zap.model, zap.price, zap.matrix_size, zap.matrix_type, zap.light_sensitivity, zap.memory_card);
		}
		space++;
	}
	cout << "|___|_______________|________________________|______________________|________________|______________|____________________________|_________________|\n";
	cout << "\n Натисніть: \n\n Enter для того, щоб зробить перевірку заново. \n\n Esc для того, щоб повернутися в головне меню. \n\n\n";
l2:
	int go = _getch(); //зчитуємо натиснуту клавішу
	if (go == 13) // перевірка чи не натиснута клавіша Enter
	{
		goto l1;
	}
	if (go == 27) // перевірка чи натиснута клавіша Esc
	{
		goto ex;
	}
	else
	{
		goto l2;
	}
ex:;
}

//Процедура виведення найдорожчої моделі заданого виробника
void Task3()
{
l1:
	system("cls");
	char y[30];
	cout << "Введіть назву виробника = ";
	cin >> y;
	iin zap; // оголошуємо змінну для роботи із записом
	float maxPrice = 0.0;
	char maxModel[l_model];
	int tmpSpace = 0;
	int space; // оголошуємо змінну, що є лічильником кількості записів на екрані
	int position = 0; // враховує к-сть виведених записів на сторінці
	int im = 0; // змінна для збереження коду натиснутої клавіші
	f.clear(); // очищуємо прапорці помилок
	f.seekp(position * countZinP * sizeof(struct iin), ios::beg); // переміщуємо вказівник на потрібний запис, що вираховується за наступною формулою

	cout << ".___._______________.________________________.______________________.________________.______________.____________________________._________________.\n";
	cout << "| № |   Виробник    |         Модель         |        Ціна          | Розмір матриці | Тип матриці  |      Світлочутивість       |  Карта пам'яті  |\n";
	cout << "|===|===============|========================|======================|================|==============|============================|=================|\n";
	space = 0; //обнуляємо значення лічильника кількості записів на екрані

	while ((!f.eof()) && (space < countZinP)) //умова виконання циклу: поки не досягли кінця файлу або кількість виведених записів на екран менше countZinP
	{
		f.read((char*)&zap, sizeof(struct iin)); //зчитування запису з файлу у змінну zap
		if (f.eof()) break; // якщо досягнуто кінець файлу, то вийти з циклу
		// виводимо поля зчитаного запису на екран
		if (fyy(y, zap.manufacturer) == 1) // Перевірка чи виробник співпадає
		{
			if (zap.price > maxPrice) // Оновлення maxPrice і maxModel якщо данна модель більш дорожча
			{
				maxPrice = zap.price;
				strcpy(maxModel, zap.model);
				tmpSpace = space;
			}
		}
		space++;
	}

	f.clear(); // очищуємо прапорці помилок
	f.seekp(position * countZinP * sizeof(struct iin), ios::beg); // переміщуємо вказівник на потрібний запис, що вираховується за наступною формулою

	space = 0; //обнуляємо значення лічильника кількості записів на екрані
	while ((!f.eof()) && (space < countZinP)) //умова виконання циклу: поки не досягли кінця файлу або кількість виведених записів на екран менше countZinP
	{
		f.read((char*)&zap, sizeof(struct iin)); //зчитування запису з файлу у змінну zap
		if (f.eof()) break; // якщо досягнуто кінець файлу, то вийти з циклу
		// виводимо поля зчитаного запису на екран
		if (tmpSpace==space)
		{
			printf("|%2d | %.14s| %.23s| %11f          | %.15s| %.13s| %.27s| %7d GB      |\n", ((1 + space) + ((position)*countZinP)), zap.manufacturer, zap.model, zap.price, zap.matrix_size, zap.matrix_type, zap.light_sensitivity, zap.memory_card);
		}
		space++;
	}

	cout << "|___|_______________|________________________|______________________|________________|______________|____________________________|_________________|\n";
	cout << "\n Натисніть: \n\n Enter для того, щоб зробить перевірку заново. \n\n Esc для того, щоб повернутися в головне меню. \n\n\n";
l2:
	int go = _getch(); //зчитуємо натиснуту клавішу
	if (go == 13) // перевірка чи не натиснута клавіша Enter
	{
		goto l1;
	}
	if (go == 27) // перевірка чи натиснута клавіша Esc
	{
		goto ex;
	}
	else
	{
		goto l2;
	}
ex:;
}

//Процедура виведення упорядкованого переліку моделей заданого виробника від нижчої ціни до вищої
void Task4() {
l1:
	system("cls");
	char y[30];
	cout << "Введіть назву виробника = ";
	cin >> y;
	iin zap;
	int space;
	int position = 0;
	int im = 0;
	f.clear();
	f.seekp(position * countZinP * sizeof(struct iin), ios::beg);

	cout << ".___._______________.________________________.______________________.________________.______________.____________________________._________________.\n";
	cout << "| № |   Виробник    |         Модель         |        Ціна          | Розмір матриці | Тип матриці  |      Світлочутивість       |  Карта пам'яті  |\n";
	cout << "|===|===============|========================|======================|================|==============|============================|=================|\n";
	space = 0;
	vector<pair<float, string>> models; 

	while ((!f.eof()) && (space < countZinP)) {
		f.read((char*)&zap, sizeof(struct iin));
		if (f.eof()) break;
		if (fyy(y, zap.manufacturer) == 1) {
			models.push_back(make_pair(zap.price, zap.model)); 
		}
		space++;
	}

	sort(models.begin(), models.end()); 

	for (const auto& model : models) {
		f.clear();
		f.seekp(position * countZinP * sizeof(struct iin), ios::beg);
		space = 0;
		while ((!f.eof()) && (space < countZinP)) {
			f.read((char*)&zap, sizeof(struct iin));
			if (f.eof()) break;
			if (fyy(y, zap.manufacturer) == 1 && strcmp(zap.model, model.second.c_str()) == 0) {
				printf("|%2d | %.14s| %.23s| %20.2f | %.15s| %.13s| %.27s| %7d GB      |\n", ((1 + space) + ((position)*countZinP)), zap.manufacturer, zap.model, model.first, zap.matrix_size,	zap.matrix_type, zap.light_sensitivity,	zap.memory_card);
				break;
			}
			space++;
		}
	}

	cout << "|___|_______________|________________________|______________________|________________|______________|____________________________|_________________|\n";
	cout << "\n Натисніть: \n\n Enter для того, щоб зробити перевірку заново. \n\n Esc для того, щоб повернутися в головне меню. \n\n\n";
l2:
	int go = _getch();
	if (go == 13) {
		goto l1;
	}
	if (go == 27) {
		goto ex;
	}
	else {
		goto l2;
	}

ex:;
}

//Процедура виведення усіх моделей фотоапаратів за заданим типом матриці;
void Task5()
{
l1:
	system("cls");
	char y[18];
	cout << "Введіть тип матриці: ";
	cin.getline(y, 18);
	iin zap;
	int space;
	int position = 0;
	int im = 0;
	f.clear();
	f.seekp(position * countZinP * sizeof(struct iin), ios::beg);

	cout << ".___._______________.________________________.______________________.________________.______________.____________________________._________________.\n";
	cout << "| № |   Виробник    |         Модель         |        Ціна          | Розмір матриці | Тип матриці  |      Світлочутивість       |  Карта пам'яті  |\n";
	cout << "|===|===============|========================|======================|================|==============|============================|=================|\n";
	space = 0;
	while ((!f.eof()) && (space < countZinP))
	{
		f.read((char*)&zap, sizeof(struct iin));
		if (f.eof()) break;
		if (fyy(y, zap.matrix_type) == 1)
		{
			printf("|%2d | %.14s| %.23s| %11f          | %.15s| %.13s| %.27s| %7d GB      |\n", ((1 + space) + ((position)*countZinP)), zap.manufacturer, zap.model, zap.price, zap.matrix_size, zap.matrix_type, zap.light_sensitivity, zap.memory_card);
		}
		space++;
	}
	cout << "|___|_______________|________________________|______________________|________________|______________|____________________________|_________________|\n";
	cout << "\n Натисніть: \n\n Enter для того, щоб зробить перевірку заново. \n\n Esc для того, щоб повернутися в головне меню. \n\n\n";
l2:
	int go = _getch(); //зчитуємо натиснуту клавішу
	if (go == 13) // перевірка чи не натиснута клавіша Enter
	{
		goto l1;
	}
	if (go == 27) // перевірка чи натиснута клавіша Esc
	{
		goto ex;
	}
	else
	{
		goto l2;
	}
ex:;
}

//Процедура виведення усіх моделей фотоапаратів за заданою світлочутливістю.
void Task6()
{
l1:
	system("cls");
	char y[18];
	cout << "Введіть світлочутливість: ";
	cin.getline(y, 18);
	iin zap;
	int space;
	int position = 0;
	int im = 0;
	f.clear();
	f.seekp(position * countZinP * sizeof(struct iin), ios::beg);

	cout << ".___._______________.________________________.______________________.________________.______________.____________________________._________________.\n";
	cout << "| № |   Виробник    |         Модель         |        Ціна          | Розмір матриці | Тип матриці  |      Світлочутивість       |  Карта пам'яті  |\n";
	cout << "|===|===============|========================|======================|================|==============|============================|=================|\n";
	space = 0;
	while ((!f.eof()) && (space < countZinP))
	{
		f.read((char*)&zap, sizeof(struct iin));
		if (f.eof()) break;
		if (fyy(y, zap.light_sensitivity) == 1)
		{
			printf("|%2d | %.14s| %.23s| %11f          | %.15s| %.13s| %.27s| %7d GB      |\n", ((1 + space) + ((position)*countZinP)), zap.manufacturer, zap.model, zap.price, zap.matrix_size, zap.matrix_type, zap.light_sensitivity, zap.memory_card);
		}
		space++;
	}
	cout << "|___|_______________|________________________|______________________|________________|______________|____________________________|_________________|\n";
	cout << "\n Натисніть: \n\n Enter для того, щоб зробить перевірку заново. \n\n Esc для того, щоб повернутися в головне меню. \n\n\n";
l2:
	int go = _getch(); //зчитуємо натиснуту клавішу
	if (go == 13) // перевірка чи не натиснута клавіша Enter
	{
		goto l1;
	}
	if (go == 27) // перевірка чи натиснута клавіша Esc
	{
		goto ex;
	}
	else
	{
		goto l2;
	}
ex:;
}

// Процедура виводу інформації про розробника
void ShowAuthorInfo()
{
	int im;
start:
	system("cls");// очистка екрана	
	cout << " |=======================================================================|\n";
	cout << " |                      \" Інформація про розробника \"                    |\n";
	cout << " |-----------------------------------------------------------------------|\n";
	cout << " | ПІБ: Гурнік Вадим Миколайович                                         |\n";
	cout << " | Вік: 19                                                               |\n";
	cout << " | Місце навчання: Національний університет харчових технологій          |\n";
	cout << " | Курс: перший                                                          |\n";
	cout << " | Група: КН-1-4                                                         |\n";
	cout << " |_______________________________________________________________________|\n";
	cout << "\nEsc --> Повернутися в головне меню.\n\n";
again://якщо ми не натиснули на щось потрібне
	im = _getch(); // получили код кнопки 
	if (im == 27) { //27 = ESC
		goto ex;
	}
	else {// != ESC
		goto again;
	}
ex:;
}

// *** Реалізація текстового інтерфейсу користувача ***
void menu()
{
	int im = 0, p = 0; //змінні для збереження кодів натиснутих клавіш при роботі з пунктами меню
	COORD crd, end; //оголошуємо змінні типу координат, що мають поле X та Y
	crd.X = 2; // задаємо початкову позицію курсору по осі Х для відображення знаку вибору
	crd.Y = 5; // задаємо початкову позицію курсору по осі Y для відображення знаку вибору
	end.X = 0; // задаємо позицію курсору по осі Х за межами меню
	end.Y = 15; // задаємо позицію курсору по осі Y за межами меню
start: // початок виведення меню на екран
	system("cls");
	cout << " |========================================================================================|\n";
	cout << " |                                \"Довідник фотоапаратів\"                                 |\n";
	cout << " |****************************************************************************************|\n";
	cout << " | * Головне меню *                                                                       |\n";
	cout << " |****************************************************************************************|\n";
	cout << " |  1. Відкрити/створити файл                                                             |\n";
	cout << " |  2. Додати запис у файл                                                                |\n";
	cout << " |  3. Редагувати запис                                                                   |\n";
	cout << " |  4. Видалити запис з файлу                                                             |\n";
	cout << " |  5. Вивести усю інформацію з файлу                                                     |\n";
	cout << " |  6. Список усіх виробників фотоапаратів                                                |\n";
	cout << " |  7. Список усіх моделей фотоапаратів із заданим розміром матриці                       |\n";
	cout << " |  8. Вивести найдорожчу модель заданого виробника                                       |\n";
	cout << " |  9. Вивести упорядкований перелік моделей заданого виробника від нижчої ціни до вищої  |\n";
	cout << " | 10. Список усіх моделей фотоапаратів за заданим типом матриці                          |\n";
	cout << " | 11. Список усіх моделей фотоапаратів за заданою світлочутливістю                       |\n";
	cout << " | 12. Про розробника                                                                     |\n";
	cout << " | 13. Вихiд                                                                              |\n";
	cout << " |========================================================================================|\n";
	if (!f.is_open()) // в залежності від того чи відкрито файл даємо відповідне повідомлення
		cout << "\n Файл відсутній, завантажте або створіть файл. \n";
	else
		cout << "\n Файл успішно завантажено.: \"" << fdir << "\"\n";
	SetConsoleCursorPosition(hConsole, crd); // переводимо курсор в позицію координат crd
	SetConsoleTextAttribute(hConsole, (WORD)((20 << 0) | 10)); //задаємо колір шрифта та фону для виведення
	cout << ">>>";
	SetConsoleTextAttribute(hConsole, (WORD)((15 << 0) | 0)); //задаємо колір шрифта та фону для виведення
	SetConsoleCursorPosition(hConsole, end);//встановлюємо курсор у нижній лівий кут
	im = _getch(); //отримуємо код натиснутої клавіші
	switch (im)
	{
	case 72: // якщо натиснута клавіша "стрілка у гору" - Up
	{
		if (crd.Y > 5) crd.Y--; // якщо не досягнуто перший пункт меню, то зменшуємо значення координат crd.Y на 1 позицію
		goto start; // переходимо на мітку start
	}
	case 80: // якщо натиснута клавіша "стрілка вниз" - Down
	{
		if (crd.Y < 17) crd.Y++; // якщо не досягнуто останній пункт меню, то збільшуємо значення координат crd.Y на 1 позицію
		goto start; // переходимо на мітку start
	}
	case 13:
	{
		p = crd.Y + 45; // обраховуємо номер пункту меню, що буде в межах
		if ((!f.is_open()) && (p != 61)) p = 50; // якщо файл не відкрито, то буде здійснено перехід до пункту відкриття файлу
		switch (p)
		{
		case 50: // якщо обрано перший пукт меню
		{
			open_new(); // викликаємо функцію відкриття файл
			goto start; // переходимо на мітку start
		}
		case 51:
		{
			addzap(); // викликаємо функцію додавання записів у файл
			goto start;// переходимо на мітку start
		}
		case 52:
		{
			editzap(); // викликаємо функцію редагування записів у файл
			goto start;// переходимо на мітку start
		}
		case 53:
		{
			delzap(); // викликаємо функцію видалення запису з файлу
			goto start;// переходимо на мітку start
		}
		case 54:
		{
			all_out(); // викликаємо функцію виведення усіх записів з файлу
			goto start;// переходимо на мітку start
		}
		case 55:
		{
			Task1();
			goto start; // переходимо на мітку start
		}
		case 56:
		{
			Task2();
			goto start; // переходимо на мітку start
		}

		case 57:
		{
			Task3();
			goto start; // переходимо на мітку start
		}
		case 58:
		{
			Task4();
			goto start; // переходимо на мітку start
		}
		case 59:
		{
			Task5();
			goto start; // переходимо на мітку start
		}
		case 60:
		{
			Task6();
			goto start; // переходимо на мітку start
		}
		case 61:
		{
			ShowAuthorInfo();
			goto start; // переходимо на мітку start
		}
		case 62:
		{
			exit_prog();// викликаємо функцію завершення виконання проєкту
			goto start; // переходимо на мітку start
		}
		default: goto start; // переходимо на мітку start
		}
	}
	default: goto start;
	}
}

//Головна функція
int main()
{
	SetConsoleCP(1251); //встановлюємо 1251 кодування для шрифту консолі
	SetConsoleOutputCP(1251);
	system("color 07"); //встановлюємо колір фону консолі чорним, а текст - білим
	menu(); // викликаємо процедуру menu
	system("pause");
	return 0;
}
